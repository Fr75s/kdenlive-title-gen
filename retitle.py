
from lxml import etree
import os, re, sys, json

from helpers import *
from constants import *


#
# Retitle Specific HELPERS
#

# Gets the sequence and clip index from the given ID of format seq{SIDX}_clip{CIDX}
def id_to_seqclip_pair(clipid: str) -> [int, int]:
	m = re.match(r"seq(\d+)_clip(\d+)", clipid)
	return (int(m[1]), int(m[2]))



# Attempts to adjust the title clip tracks inside the given kdenlive project file
# so that they match the layout seen in the given layout.json file.
#
# - projfile: The .kdenlive project document to modify
# - layoutfile: A layout.json file generated by tgen.py.
#
# Returns one of the following error codes based on what happened:
# - 0: OK
# - 1: Failed to read layout.json (layoutfile is invalid)
# - 2: Failed to read project.kdenlive (projfile is invalid)
#
def adjust_titles_in_place(projfile: str, layoutfile: str) -> int:
	# Read layout data into memory if possible
	layout = []
	try:
		with open(layoutfile, "r") as layout_json:
			layout = layout_to_sequences(json.loads(layout_json.read()))
	except:
		return 1

	# Open the project file
	with open(projfile, "r") as projfile_text:
		# Create an XML Element Tree for the project
		ptree = etree.parse(projfile_text)

		pdb("Getting Title Clip Producers...")

		# First, find all producers of format seq*_clip*. These are title clips whose times
		# we need to adjust.
		tc_producers = ptree.xpath("/mlt/producer[contains(@id, 'seq') and contains(@id, '_clip')]")

		# Additionally get the corresponding <entry> in main_bin.
		tc_entries = ptree.xpath("/mlt/playlist[@id='main_bin']/entry[contains(@producer, 'seq') and contains(@producer, '_clip')]")



		# Keep track of a few values before we go through our producer.
		# The number of clips needed to be deleted per playlist.
		to_delete = {}
		# The number of clips found per playlist.
		found = {}

		# List of sequence IDs and their corresponding duration_full
		producer_durs = {}

		# Go through each producer we found.
		pdb("Modifying Title Clip Producers...")
		for i in range(len(tc_producers)):
			seq_idx, clip_idx = id_to_seqclip_pair(tc_producers[i].get("id"))

			# Check if we have a clip we need to delete
			if (seq_idx >= len(layout) or clip_idx >= len(layout[seq_idx])):
				if not seq_idx in to_delete:
					to_delete[seq_idx] = 1
				else:
					to_delete[seq_idx] += 1
				continue
			else:
				if not seq_idx in found:
					found[seq_idx] = clip_idx
				elif clip_idx > found[seq_idx]:
					found[seq_idx] = clip_idx

			# Operating on a preexisting clip.
			clip_data = layout[seq_idx][clip_idx]

			# Set "out" duration for each
			tc_producers[i].set("out", seconds_to_timestamp(clip_data["duration_time"]))
			# Thanks to the way we do things, our producers are in the same order as the entries
			# in main bin. We can use the same index!
			tc_entries[i].set("out", seconds_to_timestamp(clip_data["duration_time"]))

			# Additionally set a few more properties for the producer.
			# kdenlive:duration_frames
			tc_producers[i].xpath("property[@name='kdenlive:duration_frames']")[0].text = frames_to_timestamp(clip_data["duration_frames"])
			# kdenlive:duration
			tc_producers[i].xpath("property[@name='kdenlive:duration']")[0].text = seconds_to_timestamp(clip_data["duration_full"])
			# length
			tc_producers[i].xpath("property[@name='length']")[0].text = str(clip_data["duration_frames"])

			# Record Duration
			producer_durs[tc_producers[i].get("id")] = {
				"out": clip_data["duration_time"],
				"full": clip_data["duration_full"]
			}

		# Tally number of clips per sequence we need to add
		to_add = {}
		for i in range(len(layout)):
			# Check if layout has sequence not found
			if not i in found:
				to_add[i] = len(layout[i])
			else:
				# Check if layout has clips not found
				if (found[i] < len(layout[i]) - 1):
					to_add[i] = (len(layout[i]) - 1) - found[i]

		print(f"ADD: {to_add}\nDEL: {to_delete}")



		# We must also find the maximum numeric ID if we need to add any titles.
		pdb("Finding Max Unused Numeric ID...")
		base_id = -1
		if (to_add != {}):
			ids = ptree.xpath("//property[@name='kdenlive:id']") + ptree.xpath("//property[@name='kdenlive:folderid']")
			for id_prop in ids:
				if int(id_prop.text) > base_id:
					base_id = int(id_prop.text)

		# Now we must adjust our playlists. To do this, we must first find every playlist which
		# has our sequences. Even though kdenlive removes the original playlist names, we can still
		# access them as the entry names are untouched.
		# Therefore, as long as the first item in the title track is a title clip, we can find
		# the correct playlist.
		seq_plays = ptree.xpath("/mlt/playlist[@id!='main_bin']/entry[contains(@producer, 'seq') and contains(@producer, '_clip')]/..")

		# Index of the main sequence in seq_plays. This sequence needs to be processed last.
		main_seq_idx = -1

		# Tracks the length of each sequence, keyed by the UUID of the sequence.
		seq_times = {}

		pdb("Modifying Playlists & Tractors...")
		for i in range(len(seq_plays)):
			pl = seq_plays[i]

			# Check if this is the main sequence title track playlist. If so, save handling it
			# until the other sequences have been processed.
			if (pl[0].get("producer")[:5] == "seq0_"):
				main_seq_idx = i
				continue

			# Get the tractor merging the playlist and the other video track
			merge_trac = ptree.xpath(f"/mlt/tractor/track[@producer='{pl.get("id")}']/..")[0]

			# Get the sequence tractor. This contains the sequence index, so get that too.
			seq_trac = ptree.xpath(f"/mlt/tractor/track[@producer='{merge_trac.get("id")}']/..")[0]
			# NOTE: This method of getting sequence index assumes that the sequence is named
			# "Sequence {IDX}". This won't work if the sequence was renamed! If sequence name
			# changes are implemented later, this will need to change, likely by getting the
			# index in the main playlist.
			seq_idx = int(seq_trac.find("property[@name='kdenlive:clipname']").text[9:])

			# Check if we need to create any new titles before we modify the playlist.
			if (seq_idx in to_add):
				# Looks like we need to create some new titles!
				pdb(f"Creating New Titles for Sequence {seq_idx}")

				# Get the folder ID by looking it up from the first entry.
				# This produces a warning which I ignore.
				folder_id = ptree.getroot().find(f"producer[@id='{pl[0].get("producer")}']").find("property[@name='kdenlive:folderid']").text

				# Create and add each producer to the tree & playlist
				for i in range(to_add[seq_idx]):
					clip_data = layout[seq_idx][found[seq_idx] + i + 1]

					# Generate Producer XML
					producer_str = title_to_producer(
						title_obj = clip_data,
						projdir = os.path.dirname(projfile),
						folder_id = folder_id,
						clip_id = (base_id + 1) + i,
						producer_id = found[seq_idx] + i + 1,
						seq_id = seq_idx
					)

					# Add the producer to the tree
					ptree.getroot().insert(ptree.getroot().index(ptree.getroot().find(f"producer[@id='seq{seq_idx}_clip{found[seq_idx]}']")) + 1, etree.fromstring(producer_str))

					# Also add it to the main_bin entry list.
					main_bin_entry_str = main_bin_entry(
						seq_id = seq_idx,
						pl_id = found[seq_idx] + i + 1,
						duration = clip_data["duration_time"]
					)
					main_bin = ptree.getroot().find("playlist[@id='main_bin']")
					main_bin.insert(main_bin.index(main_bin.find(f"entry[@producer='seq{seq_idx}_clip{found[seq_idx]}']")) + 1, etree.fromstring(main_bin_entry_str))

					producer_durs[f"seq{seq_idx}_clip{found[seq_idx] + i + 1}"] = {
						"out": clip_data["duration_time"],
						"full": clip_data["duration_full"]
					}

					# Insert the producer into the playlist
					# Note that since we know our playlist was found, it has at least one element
					# and therefore the new item is a content clip.

					# Create Entry
					entry_str = playlist_entry(
						seq_id = seq_idx,
						pl_id = found[seq_idx] + i + 1,
						unique_id = (base_id + 1) + i,
						duration = clip_data["duration_time"],
						fade_dur = FADE_DURATION
					)

					# Get blank length
					blank_len = CONTENT_GAP
					if ("before_pause" in clip_data["modifiers"]):
						blank_len = clip_data["modifiers"]["before_pause"]

					# Add a new blank and the entry to the playlist.
					pl.append(etree.fromstring(playlist_blank(blank_len)))
					pl.append(etree.fromstring(entry_str))

					pdb(f"Added Title {found[seq_idx] + 1 + i}")

				base_id += to_add[seq_idx]


			# Adjust existing elements of the playlist.
			# While doing so, track the new length of the sequence.
			this_len = 0.0

			for i in range(0, len(layout[seq_idx]) * 2, 2):
				durations = producer_durs[pl[i].get("producer")]

				# Adjust Entry
				# Adjust out
				pl[i].set("out", seconds_to_timestamp(durations["out"]))

				# Adjust fades
				# Fade-out filter
				pl[i].find("filter[@in]").set("in", seconds_to_timestamp(durations["out"] - FADE_DURATION))
				pl[i].find("filter[@in]").set("out", seconds_to_timestamp(durations["out"]))
				# Fade-in filter
				pl[i].xpath("filter[not(@in)]")[0].set("out", seconds_to_timestamp(FADE_DURATION))

				this_len += durations["full"]
				if (i > 0):
					# Additionally handle and adjust gap before
					gap_size = FADE_DURATION
					if ("before_pause" in layout[seq_idx][i // 2]["modifiers"]):
						gap_size = layout[seq_idx][i // 2]["modifiers"]["before_pause"]

					pl[i - 1].set("length", seconds_to_timestamp(gap_size))
					this_len += gap_size

			# Delete elements of the playlist to be removed.
			if (seq_idx in to_delete):
				for i in range(to_delete[seq_idx]):
					pl.remove(pl[len(layout[seq_idx]) * 2])
					pl.remove(pl[len(layout[seq_idx]) * 2 - 1])

			pdb(f"Playlist {pl.get('id')} Regenerated.")


			# Modify the tractor containing this playlist.
			merge_trac.set("out", seconds_to_timestamp(this_len - 1 / FRAMERATE))

			# Modify the sequence tractor containing the prior tractor. Set its length to be the
			# length of the longest track.

			# First, find the longest track length.
			longest_len = this_len
			track_ids = seq_trac.xpath("track[position() > 1]/@producer")
			for tid in track_ids:
				track = ptree.xpath(f"/mlt/tractor/track[@producer='{tid}']/..")[0]
				if ("out" in track.attrib):
					track_dur = timestamp_to_seconds(track.get("out"))
					if (track_dur > longest_len):
						longest_len = track_dur

			# Set this sequence's length everywhere it's used.
			seq_trac.set("out", seconds_to_timestamp(longest_len - 1 / FRAMERATE))
			seq_trac.find("property[@name='kdenlive:duration']").text = seconds_to_timestamp(longest_len)
			seq_trac.find("property[@name='kdenlive:maxduration']").text = str(seconds_to_frames(longest_len))
			seq_trac.find("property[@name='kdenlive:sequenceproperties.zoneout']").text = str(seconds_to_frames(longest_len))

			# Save the sequence length for later, using the UUID of the sequence for ease of
			# access.
			seq_times[seq_trac.get("id")] = r3(longest_len)

			pdb(f"Corresponding Sequence Regenerated.\n")

		print(seq_times)

		print(main_seq_idx)

		#print(etree.tostring(ptree.getroot().find("playlist[@id='main_bin']"), pretty_print=True).decode())


	return 0

print("Status:", adjust_titles_in_place("TESTING/project.kdenlive", "TESTING/titles/layout.json"))
